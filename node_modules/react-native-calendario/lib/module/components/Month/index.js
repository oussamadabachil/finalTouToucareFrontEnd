import React, { useCallback, useMemo } from 'react';
import { View, Text } from 'react-native';
import { Month } from 'react-native-month';
import moment from 'moment';
import { isValidDate, getMonthNames, isSameDate } from '../../utils/date';
import { shouldRenderMonth, isMonthDrawn } from './utils';
import styles from './styles';
const SHOULD_NOT_UPDATE = true;
const EmptyMonth = /*#__PURE__*/React.memo(props => {
  const content = useMemo(() => ({
    height: props.height,
    justifyContent: 'center',
    alignItems: 'center'
  }), [props.height]);
  return /*#__PURE__*/React.createElement(View, {
    style: [content, props.theme.emptyMonthContainerStyle]
  }, /*#__PURE__*/React.createElement(Text, {
    style: [styles.emptyMonthText, props.theme.emptyMonthTextStyle],
    allowFontScaling: false
  }, props.name));
}, () => SHOULD_NOT_UPDATE);
const MonthTitle = /*#__PURE__*/React.memo(props => /*#__PURE__*/React.createElement(Text, {
  allowFontScaling: false,
  style: [styles.monthTitleText, props.theme.monthTitleTextStyle]
}, props.name), () => SHOULD_NOT_UPDATE);
export default /*#__PURE__*/React.memo(props => {
  const {
    month,
    year,
    minDate,
    maxDate,
    firstDayMonday,
    showMonthTitle,
    renderAllMonths,
    calculateMonthHeightDynamically,
    onMonthLayout,
    monthNames,
    theme = {},
    height,
    locale,
    index
  } = props;
  const MONTH_NAMES = Array.isArray(monthNames) && monthNames.length === 12 ? monthNames : getMonthNames(locale);
  const monthName = `${MONTH_NAMES[month]} ${year}`;
  const isEmptyMonth = !renderAllMonths && !calculateMonthHeightDynamically && (index < props.firstViewableIndex - props.viewableRangeOffset || index > props.lastViewableIndex);
  const handleOnLayout = useCallback(e => {
    if (calculateMonthHeightDynamically) {
      onMonthLayout(index, e);
    }
  }, [calculateMonthHeightDynamically, index, onMonthLayout]);
  const monthStyle = useMemo(() => calculateMonthHeightDynamically ? {} : {
    height
  }, [calculateMonthHeightDynamically, height]);
  if (isEmptyMonth) {
    return /*#__PURE__*/React.createElement(EmptyMonth, {
      name: monthName,
      height: height,
      theme: theme
    });
  }
  const min = minDate && isValidDate(new Date(minDate)) ? moment(minDate, 'YYYY-MM-DD').toDate() : undefined;
  const max = maxDate && isValidDate(new Date(maxDate)) ? moment(maxDate, 'YYYY-MM-DD').toDate() : undefined;
  return /*#__PURE__*/React.createElement(View, {
    style: monthStyle,
    onLayout: handleOnLayout
  }, showMonthTitle && /*#__PURE__*/React.createElement(MonthTitle, {
    name: monthName,
    theme: theme
  }), /*#__PURE__*/React.createElement(View, null, /*#__PURE__*/React.createElement(Month, {
    month: month,
    year: year,
    disabledDays: props.disabledDays,
    disableOffsetDays: props.disableOffsetDays,
    disableRange: props.disableRange,
    startDate: props.startDate,
    endDate: props.endDate,
    firstDayMonday: firstDayMonday,
    locale: props.locale,
    markedDays: props.markedDays,
    maxDate: max,
    minDate: min,
    onPress: props.onPress,
    renderDayContent: props.renderDayContent,
    showWeekdays: props.showWeekdays,
    theme: props.theme,
    dayNames: props.dayNames
  })));
}, (prevProps, nextProps) => {
  if (prevProps.disableRange !== nextProps.disableRange) {
    return false;
  }
  if ((prevProps.index < prevProps.firstViewableIndex - prevProps.viewableRangeOffset || prevProps.index > prevProps.lastViewableIndex) && nextProps.index >= nextProps.firstViewableIndex && nextProps.index <= nextProps.lastViewableIndex) {
    return false;
  }
  if ((!nextProps.dayNames || !nextProps.monthNames) && prevProps.locale !== nextProps.locale) {
    return false;
  }
  const currentMonth = moment(nextProps.firstMonthToRender).add(nextProps.index, 'months');
  if (prevProps.disableRange === nextProps.disableRange) {
    if (nextProps.disableRange) {
      if (prevProps.startDate !== nextProps.startDate) {
        if (!prevProps.startDate && moment(nextProps.startDate).isSame(currentMonth, 'month')) {
          return false;
        }
        if (prevProps.startDate && (moment(prevProps.startDate).isSame(currentMonth, 'month') || moment(nextProps.startDate).isSame(currentMonth, 'month'))) {
          return false;
        }
      }
    } else {
      const startDateChanged = prevProps.startDate instanceof Date && nextProps.startDate instanceof Date && !isSameDate(prevProps.startDate, nextProps.startDate) || prevProps.startDate !== nextProps.startDate;
      const endDateChanged = prevProps.endDate instanceof Date && nextProps.endDate instanceof Date && !isSameDate(prevProps.endDate, nextProps.endDate) || prevProps.endDate !== nextProps.endDate;
      if (startDateChanged || endDateChanged) {
        if (isMonthDrawn(currentMonth.year(), currentMonth.month(), prevProps.startDate, prevProps.endDate) !== isMonthDrawn(currentMonth.year(), currentMonth.month(), nextProps.startDate, nextProps.endDate) || prevProps.startDate instanceof Date && moment(prevProps.startDate).isSame(currentMonth, 'month') && (startDateChanged || endDateChanged) || nextProps.startDate instanceof Date && moment(nextProps.startDate).isSame(currentMonth, 'month') && startDateChanged || prevProps.endDate instanceof Date && moment(prevProps.endDate).isSame(currentMonth, 'month') && endDateChanged || nextProps.endDate instanceof Date && moment(nextProps.endDate).isSame(currentMonth, 'month') && endDateChanged) {
          return false;
        }
      }
    }
  } else {
    return false;
  }
  if (shouldRenderMonth(currentMonth, prevProps.minDate, nextProps.minDate) || shouldRenderMonth(currentMonth, prevProps.maxDate, nextProps.maxDate)) {
    return false;
  }
  return true;
});
//# sourceMappingURL=index.js.map