"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeMonth = require("react-native-month");
var _moment = _interopRequireDefault(require("moment"));
var _date = require("../../utils/date");
var _utils = require("./utils");
var _styles = _interopRequireDefault(require("./styles"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const SHOULD_NOT_UPDATE = true;
const EmptyMonth = /*#__PURE__*/_react.default.memo(props => {
  const content = (0, _react.useMemo)(() => ({
    height: props.height,
    justifyContent: 'center',
    alignItems: 'center'
  }), [props.height]);
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [content, props.theme.emptyMonthContainerStyle]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: [_styles.default.emptyMonthText, props.theme.emptyMonthTextStyle],
    allowFontScaling: false
  }, props.name));
}, () => SHOULD_NOT_UPDATE);
const MonthTitle = /*#__PURE__*/_react.default.memo(props => /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
  allowFontScaling: false,
  style: [_styles.default.monthTitleText, props.theme.monthTitleTextStyle]
}, props.name), () => SHOULD_NOT_UPDATE);
var _default = /*#__PURE__*/_react.default.memo(props => {
  const {
    month,
    year,
    minDate,
    maxDate,
    firstDayMonday,
    showMonthTitle,
    renderAllMonths,
    calculateMonthHeightDynamically,
    onMonthLayout,
    monthNames,
    theme = {},
    height,
    locale,
    index
  } = props;
  const MONTH_NAMES = Array.isArray(monthNames) && monthNames.length === 12 ? monthNames : (0, _date.getMonthNames)(locale);
  const monthName = `${MONTH_NAMES[month]} ${year}`;
  const isEmptyMonth = !renderAllMonths && !calculateMonthHeightDynamically && (index < props.firstViewableIndex - props.viewableRangeOffset || index > props.lastViewableIndex);
  const handleOnLayout = (0, _react.useCallback)(e => {
    if (calculateMonthHeightDynamically) {
      onMonthLayout(index, e);
    }
  }, [calculateMonthHeightDynamically, index, onMonthLayout]);
  const monthStyle = (0, _react.useMemo)(() => calculateMonthHeightDynamically ? {} : {
    height
  }, [calculateMonthHeightDynamically, height]);
  if (isEmptyMonth) {
    return /*#__PURE__*/_react.default.createElement(EmptyMonth, {
      name: monthName,
      height: height,
      theme: theme
    });
  }
  const min = minDate && (0, _date.isValidDate)(new Date(minDate)) ? (0, _moment.default)(minDate, 'YYYY-MM-DD').toDate() : undefined;
  const max = maxDate && (0, _date.isValidDate)(new Date(maxDate)) ? (0, _moment.default)(maxDate, 'YYYY-MM-DD').toDate() : undefined;
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: monthStyle,
    onLayout: handleOnLayout
  }, showMonthTitle && /*#__PURE__*/_react.default.createElement(MonthTitle, {
    name: monthName,
    theme: theme
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, null, /*#__PURE__*/_react.default.createElement(_reactNativeMonth.Month, {
    month: month,
    year: year,
    disabledDays: props.disabledDays,
    disableOffsetDays: props.disableOffsetDays,
    disableRange: props.disableRange,
    startDate: props.startDate,
    endDate: props.endDate,
    firstDayMonday: firstDayMonday,
    locale: props.locale,
    markedDays: props.markedDays,
    maxDate: max,
    minDate: min,
    onPress: props.onPress,
    renderDayContent: props.renderDayContent,
    showWeekdays: props.showWeekdays,
    theme: props.theme,
    dayNames: props.dayNames
  })));
}, (prevProps, nextProps) => {
  if (prevProps.disableRange !== nextProps.disableRange) {
    return false;
  }
  if ((prevProps.index < prevProps.firstViewableIndex - prevProps.viewableRangeOffset || prevProps.index > prevProps.lastViewableIndex) && nextProps.index >= nextProps.firstViewableIndex && nextProps.index <= nextProps.lastViewableIndex) {
    return false;
  }
  if ((!nextProps.dayNames || !nextProps.monthNames) && prevProps.locale !== nextProps.locale) {
    return false;
  }
  const currentMonth = (0, _moment.default)(nextProps.firstMonthToRender).add(nextProps.index, 'months');
  if (prevProps.disableRange === nextProps.disableRange) {
    if (nextProps.disableRange) {
      if (prevProps.startDate !== nextProps.startDate) {
        if (!prevProps.startDate && (0, _moment.default)(nextProps.startDate).isSame(currentMonth, 'month')) {
          return false;
        }
        if (prevProps.startDate && ((0, _moment.default)(prevProps.startDate).isSame(currentMonth, 'month') || (0, _moment.default)(nextProps.startDate).isSame(currentMonth, 'month'))) {
          return false;
        }
      }
    } else {
      const startDateChanged = prevProps.startDate instanceof Date && nextProps.startDate instanceof Date && !(0, _date.isSameDate)(prevProps.startDate, nextProps.startDate) || prevProps.startDate !== nextProps.startDate;
      const endDateChanged = prevProps.endDate instanceof Date && nextProps.endDate instanceof Date && !(0, _date.isSameDate)(prevProps.endDate, nextProps.endDate) || prevProps.endDate !== nextProps.endDate;
      if (startDateChanged || endDateChanged) {
        if ((0, _utils.isMonthDrawn)(currentMonth.year(), currentMonth.month(), prevProps.startDate, prevProps.endDate) !== (0, _utils.isMonthDrawn)(currentMonth.year(), currentMonth.month(), nextProps.startDate, nextProps.endDate) || prevProps.startDate instanceof Date && (0, _moment.default)(prevProps.startDate).isSame(currentMonth, 'month') && (startDateChanged || endDateChanged) || nextProps.startDate instanceof Date && (0, _moment.default)(nextProps.startDate).isSame(currentMonth, 'month') && startDateChanged || prevProps.endDate instanceof Date && (0, _moment.default)(prevProps.endDate).isSame(currentMonth, 'month') && endDateChanged || nextProps.endDate instanceof Date && (0, _moment.default)(nextProps.endDate).isSame(currentMonth, 'month') && endDateChanged) {
          return false;
        }
      }
    }
  } else {
    return false;
  }
  if ((0, _utils.shouldRenderMonth)(currentMonth, prevProps.minDate, nextProps.minDate) || (0, _utils.shouldRenderMonth)(currentMonth, prevProps.maxDate, nextProps.maxDate)) {
    return false;
  }
  return true;
});
exports.default = _default;
//# sourceMappingURL=index.js.map